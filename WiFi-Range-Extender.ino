// Wifi Range Extender (NAPT with JSON API)
// Based on Range Extender NAPT
// - https://github.com/esp8266/Arduino/blob/master/libraries/ESP8266WiFi/examples/RangeExtender-NAPT/RangeExtender-NAPT.ino
//
// WiFi Examples see https://github.com/esp8266/Arduino/tree/master/libraries/ESP8266WiFi/examples
// Also see https://www.survivingwithandroid.com/esp32-rest-api-esp32-api-server/

#if LWIP_FEATURES && !LWIP_IPV6

#define HAVE_NETDUMP 0

#include "secrets.h"

// Wifi Range extender NAPT
#include <ESP8266WiFi.h>
#include <lwip/napt.h>
#include <lwip/dns.h>
// #include <dhcpserver.h>

// LLMNR webserver
#include <ESP8266LLMNR.h>
#include <ESP8266WebServer.h>

// ArduinoJSON Lib
#include <ArduinoJson.h>

#define NAPT 1000
#define NAPT_PORT 10

#if HAVE_NETDUMP

#include <NetDump.h>

void dump(int netif_idx, const char* data, size_t len, int out, int success) {
  (void)success;
  Serial.print(out ? F("out ") : F(" in "));
  Serial.printf("%d ", netif_idx);

  // optional filter example: if (netDump_is_ARP(data))
  {
    netDump(Serial, data, len);
    //netDumpHex(Serial, data, len);
  }
}
#endif
// Webserver on Port 80
ESP8266WebServer server(80);
// JSON data buffer
StaticJsonDocument<5000> jsonDocument;
char buffer[5000];

// HTML
void handleHttpRoot() {
  Serial.printf("handleHttpRoot");
  char temp[400];
  snprintf(temp, 400,

           "<html>\
  <head>\
    <meta http-equiv='refresh' content='5'/>\
    <title>ESP8266 - WiFi Range Extender</title>\
    <style>\
      body { background-color: #cccccc; font-family: Arial, Helvetica, Sans-Serif; Color: #000088; }\
    </style>\
  </head>\
  <body>\
    <h1>ESP8266 - Wifi Range Extender NAPT with Json API (v0.1)</h1>\
    <ul>\
    <li><a href='/info'>Info</a></li>\
    <li><a href='/scan'>Network Scan</a></li>\
    </ul>\
  </body>\
</html>");
  server.send(200, "text/html", temp);
}
// 404
void handleNotFound() {
  server.send(404, "text/plain", "Not Found");
}
// JSON
void handleInfo() {
  Serial.printf("handleInfo");
  int sec = millis() / 1000;
  int min = sec / 60;
  int hr = min / 60;
  char time[8];
  snprintf(time, 8, "%02d:%02d:%02d", hr, min, sec);  
  // TODO avoid String conversion! 
  // https://stackoverflow.com/questions/35227449/convert-ip-or-mac-address-from-string-to-byte-array-arduino-or-c
  String ipStr = WiFi.localIP().toString();
  int len = ipStr.length() + 1;
  char ip[len];
  ipStr.toCharArray(ip, len);
  String gipStr = WiFi.gatewayIP().toString();
  int len2 = gipStr.length() + 1;
  char gip[len2];
  gipStr.toCharArray(gip, len2);
  // the BSSID is the MAC address of the wireless access point (WAP) 
  // generated by combining the 24 bit Organization Unique Identifier (the manufacturer's identity) 
  // and the manufacturer's assigned 24-bit identifier for the radio chipset in the WAP
  uint8_t *ptrBSSID = WiFi.BSSID();
  //uint8_t bssid[6];
  //memcpy(bssid,ptrBSSID,6);
  //char* ipc=(char*) &bssid;
  char bssidChar[20];
  //converts to hexadecimal base.
  snprintf(bssidChar, 20, "%x:%x:%x:%x:%x:%x", ptrBSSID[0],ptrBSSID[1],ptrBSSID[2],ptrBSSID[3],ptrBSSID[4],ptrBSSID[5]);

  // Write JSON document
  jsonDocument.clear();
  addJsonObj("IP", ip, "");
  addJsonObj("Gateway IP", gip, "");
  addJsonObj("MAC Address of WAP", bssidChar, "");
  addJsonObj("Uptime", time , "hh:mm:ss");
  server.send(200, "application/json", buffer);
}
// JSON
void handleNetScan() {
  Serial.printf("handleNetScan");
  // n = number of networks found
  int n = WiFi.scanNetworks();
  Serial.println("scan done");
  jsonDocument.clear();
  if (n == 0) {
    Serial.println("no networks found");
  } else {
    Serial.println(n + " networks found");
    for (int i = 0; i < n; ++i) {
      // Print SSID, RSSI, encryption for each network found
      String ssid = WiFi.SSID(i);
      int rssi = WiFi.RSSI(i);
      addJsonObj(ssid, rssi, getEncryptionType(WiFi.encryptionType(i)));
      delay(10);
    }
  }
  server.send(200, "application/json", buffer);
}

void setup() {
  pinMode(LED_BUILTIN, OUTPUT);     // Initialize the LED_BUILTIN pin as an output
  Serial.begin(115200);
  Serial.printf("\n\nNAPT Range extender\n");
  Serial.printf("Heap on start: %d\n", ESP.getFreeHeap());

#if HAVE_NETDUMP
  phy_capture = dump;
#endif
  connectToWifi();
  startWebServer();
}

#else

void setup() {
  Serial.begin(115200);
  Serial.printf("\n\nNAPT not supported in this configuration\n");
}

#endif


void loop() {
  server.handleClient();

  // Check if a client has connected
  //WiFiClient client = server.available();

  // Do we have a client?
  //if (!client) return;

  //Serial.println(F("New client connected"));

  //client.setTimeout(5000); // default is 1000

  // Read the request (we ignore the content in this example)
  //while (client.available()) client.read();
}

// WIFI and DNS
void connectToWifi() {
  // first, connect to STA so we can get a proper local DNS server
  WiFi.mode(WIFI_STA);
  WiFi.begin(STASSID, STAPSK);

  // Wait for connection (blink LED)
  while (WiFi.status() != WL_CONNECTED) {
    Serial.print('.');
    digitalWrite(LED_BUILTIN, HIGH);
    delay(500);
    digitalWrite(LED_BUILTIN, LOW);
  }

  Serial.printf("\nSTA: %s (dns: %s / %s)\n",
                WiFi.localIP().toString().c_str(),
                WiFi.dnsIP(0).toString().c_str(),
                WiFi.dnsIP(1).toString().c_str());

// By default, DNS option will point to the interface IP
  // Instead, point it to the real DNS server.
  // Notice that:
  // - DhcpServer class only supports IPv4
  // - Only a single IP can be set
  auto& server = WiFi.softAPDhcpServer();
  server.setDns(WiFi.dnsIP(0));

  WiFi.softAPConfig(  // enable AP, with android-compatible google domain
    IPAddress(192, 168, 180, 1),
    IPAddress(192, 168, 180, 1),
    IPAddress(255, 255, 255, 0));

    // WiFi.softAP(ssid, password, channel, hidden, max_connection)
  WiFi.softAP(STASSID "ext", STAPSK, 13, HIDDEN, 6);
  Serial.printf("AP: %s\n", WiFi.softAPIP().toString().c_str());

  Serial.printf("Heap before: %d\n", ESP.getFreeHeap());
  err_t ret = ip_napt_init(NAPT, NAPT_PORT);
  Serial.printf("ip_napt_init(%d,%d): ret=%d (OK=%d)\n", NAPT, NAPT_PORT, (int)ret, (int)ERR_OK);
  if (ret == ERR_OK) {
    ret = ip_napt_enable_no(SOFTAP_IF, 1);
    Serial.printf("ip_napt_enable_no(SOFTAP_IF): ret=%d (OK=%d)\n", (int)ret, (int)ERR_OK);
    if (ret == ERR_OK) {
      digitalWrite(LED_BUILTIN, LOW);   // Turn the LED on (Note that LOW is the voltage level
      Serial.printf("WiFi Network '%s' with same password is now NATed behind '%s'\n", STASSID "ext", STASSID);
    }
  }
  Serial.printf("Heap after napt init: %d\n", ESP.getFreeHeap());
  if (ret != ERR_OK) {
    digitalWrite(LED_BUILTIN, HIGH);  // LED off by making the voltage HIGH
    Serial.printf("NAPT initialization failed\n");
  }
}

// Start LLMNR responder
void startWebServer() {
  LLMNR.begin("esp8266");
  Serial.println("LLMNR responder started");
  // Start HTTP server
  server.onNotFound(handleNotFound);
  server.on("/", handleHttpRoot);
  server.on("/scan", handleNetScan);
  server.on("/info", handleInfo);
  server.begin();
  Serial.println("HTTP server started");
}

char* getEncryptionType(int t) {
  // read the encryption type and return the name:
  char *type;
  switch (t) {
  case ENC_TYPE_WEP:
    type = "WEP";
  case ENC_TYPE_TKIP:
    type = "WPA";
  case ENC_TYPE_CCMP:
    type = "WPA2";
  case ENC_TYPE_NONE:
    type = "None";
  case ENC_TYPE_AUTO:
    type = "Auto";
  }
  return type;
}

void createJson(char *tag, float value, char *unit) {  
  jsonDocument.clear();  
  jsonDocument["type"] = tag;
  jsonDocument["value"] = value;
  jsonDocument["unit"] = unit;
  serializeJson(jsonDocument, buffer);
}

void addJsonObj(char *tag, char *value, char *unit) {
  JsonObject obj = jsonDocument.createNestedObject();
  obj["type"] = tag;
  obj["value"] = value;
  obj["unit"] = unit;
  serializeJson(jsonDocument, buffer);
}

void addJsonObj(String ssid, int rsid, char *enc) {
  JsonObject obj = jsonDocument.createNestedObject();
  obj["ssid"] = ssid;
  obj["dBm"] = rsid;
  obj["enc"] = enc;
  serializeJson(jsonDocument, buffer);
}

void addJsonObj(char *tag, float value, char *unit) {
  JsonObject obj = jsonDocument.createNestedObject();
  obj["type"] = tag;
  obj["value"] = value;
  obj["unit"] = unit; 
}
